// --------- This code has been automatically generated !!! 2018-04-20T14:13:31.080Z
"use strict";
require("requirish")._(module);
/**
 * @module opcua.address_space.types
 */
var assert = require("better-assert");
var util = require("util");
var _  = require("underscore");
var makeNodeId = require("lib/datamodel/nodeid").makeNodeId;
var schema_helpers =  require("lib/misc/factories_schema_helpers");
var extract_all_fields                       = schema_helpers.extract_all_fields;
var resolve_schema_field_types               = schema_helpers.resolve_schema_field_types;
var initialize_field                         = schema_helpers.initialize_field;
var initialize_field_array                   = schema_helpers.initialize_field_array;
var check_options_correctness_against_schema = schema_helpers.check_options_correctness_against_schema;
var _defaultTypeMap = require("lib/misc/factories_builtin_types")._defaultTypeMap;
var ec = require("lib/misc/encode_decode");
var encodeArray = ec.encodeArray;
var decodeArray = ec.decodeArray;
var makeExpandedNodeId = ec.makeExpandedNodeId;
var generate_new_id = require("lib/misc/factories").generate_new_id;
var _enumerations = require("lib/misc/factories_enumerations")._private._enumerations;
var schema = require("../schemas/BrowseDescription_schema").BrowseDescription_Schema;
var BaseUAObject = require("lib/misc/factories_baseobject").BaseUAObject;

/**
 * A request to browse the the references from a node.
 * 
 * @class BrowseDescription
 * @constructor
 * @extends BaseUAObject
 * @param  options {Object}
 * @param  [options.nodeId] {NodeId} The id of the node to browse.
 * @param  [options.browseDirection] {BrowseDirection} The direction of the references to return.
 * @param  [options.referenceTypeId] {NodeId} The type of references to return.Specifies the NodeId of the ReferenceType to follow. Only instances of this ReferenceType or its subtype are returned.If not specified then all ReferenceTypes are returned and includeSubtypes is ignored.
 * @param  [options.includeSubtypes] {Boolean} Includes subtypes of the reference type.
 * @param  [options.nodeClassMask] {UInt32} A mask indicating which node classes to return. 0 means return all nodes.
 * @param  [options.resultMask = 0] {UInt32} A mask indicating which fields in the ReferenceDescription should be returned in the results.
 */
function BrowseDescription(options)
{
    options = options || {};
    /* istanbul ignore next */
    if (schema_helpers.doDebug) { check_options_correctness_against_schema(this,schema,options); }
    var self = this;
    assert(this instanceof BaseUAObject); //  ' keyword "new" is required for constructor call')
    resolve_schema_field_types(schema);

    BaseUAObject.call(this,options);

    /**
      * The id of the node to browse.
      * @property nodeId
      * @type {NodeId}
      */
    self.nodeId = initialize_field(schema.fields[0], options.nodeId);

    /**
      * The direction of the references to return.
      * @property browseDirection
      * @type {BrowseDirection}
      */
    self.setBrowseDirection(initialize_field(schema.fields[1], options.browseDirection));

    /**
      * The type of references to return.Specifies the NodeId of the ReferenceType to follow. Only instances of this ReferenceType or its subtype are returned.If not specified then all ReferenceTypes are returned and includeSubtypes is ignored.
      * @property referenceTypeId
      * @type {NodeId}
      */
    self.referenceTypeId = initialize_field(schema.fields[2], options.referenceTypeId);

    /**
      * Includes subtypes of the reference type.
      * @property includeSubtypes
      * @type {Boolean}
      */
    self.includeSubtypes = initialize_field(schema.fields[3], options.includeSubtypes);

    /**
      * A mask indicating which node classes to return. 0 means return all nodes.
      * @property nodeClassMask
      * @type {UInt32}
      */
    self.nodeClassMask = initialize_field(schema.fields[4], options.nodeClassMask);

    /**
      * A mask indicating which fields in the ReferenceDescription should be returned in the results.
      * @property resultMask
      * @type {UInt32}
      * @default  0
      */
    self.resultMask = initialize_field(schema.fields[5], options.resultMask);

   // Object.preventExtensions(self);
}
util.inherits(BrowseDescription,BaseUAObject);

//## Define Enumeration setters
BrowseDescription.prototype.setBrowseDirection = function(value) {
   var coercedValue = _enumerations.BrowseDirection.typedEnum.get(value);
   /* istanbul ignore next */
   if (coercedValue === undefined || coercedValue === null) {
      throw new Error("value cannot be coerced to BrowseDirection: " + value);
   }
   this.browseDirection = coercedValue;
};
BrowseDescription.prototype.encodingDefaultBinary = makeExpandedNodeId(516,0);
BrowseDescription.prototype.encodingDefaultXml = makeExpandedNodeId(515,0);
BrowseDescription.prototype._schema = schema;

var encode_NodeId = _defaultTypeMap.NodeId.encode;
var decode_NodeId = _defaultTypeMap.NodeId.decode;
var encode_BrowseDirection = _enumerations.BrowseDirection.encode;
var decode_BrowseDirection = _enumerations.BrowseDirection.decode;
var encode_Boolean = _defaultTypeMap.Boolean.encode;
var decode_Boolean = _defaultTypeMap.Boolean.decode;
var encode_UInt32 = _defaultTypeMap.UInt32.encode;
var decode_UInt32 = _defaultTypeMap.UInt32.decode;
/**
 * encode the object into a binary stream
 * @method encode
 *
 * @param stream {BinaryStream} 
 */
BrowseDescription.prototype.encode = function(stream,options) {
    // call base class implementation first
    BaseUAObject.prototype.encode.call(this,stream,options);
    encode_NodeId(this.nodeId,stream);
    encode_BrowseDirection(this.browseDirection,stream);
    encode_NodeId(this.referenceTypeId,stream);
    encode_Boolean(this.includeSubtypes,stream);
    encode_UInt32(this.nodeClassMask,stream);
    encode_UInt32(this.resultMask,stream);
};
/**
 * decode the object from a binary stream
 * @method decode
 *
 * @param stream {BinaryStream} 
 * @param [option] {object} 
 */
BrowseDescription.prototype.decode = function(stream,options) {
    // call base class implementation first
    BaseUAObject.prototype.decode.call(this,stream,options);
    this.nodeId = decode_NodeId(stream,options);
    this.browseDirection = decode_BrowseDirection(stream,options);
    this.referenceTypeId = decode_NodeId(stream,options);
    this.includeSubtypes = decode_Boolean(stream,options);
    this.nodeClassMask = decode_UInt32(stream,options);
    this.resultMask = decode_UInt32(stream,options);
};
BrowseDescription.possibleFields = [
  "nodeId",
         "browseDirection",
         "referenceTypeId",
         "includeSubtypes",
         "nodeClassMask",
         "resultMask"
];


exports.BrowseDescription = BrowseDescription;
var register_class_definition = require("lib/misc/factories_factories").register_class_definition;
register_class_definition("BrowseDescription",BrowseDescription);
