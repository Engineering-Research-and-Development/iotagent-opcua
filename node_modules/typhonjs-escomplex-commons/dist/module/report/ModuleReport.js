'use strict';

Object.defineProperty(exports, "__esModule", {
   value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AbstractReport2 = require('./AbstractReport');

var _AbstractReport3 = _interopRequireDefault(_AbstractReport2);

var _AggregateMethodReport = require('./AggregateMethodReport');

var _AggregateMethodReport2 = _interopRequireDefault(_AggregateMethodReport);

var _ClassMethodReport = require('./ClassMethodReport');

var _ClassMethodReport2 = _interopRequireDefault(_ClassMethodReport);

var _ClassReport = require('./ClassReport');

var _ClassReport2 = _interopRequireDefault(_ClassReport);

var _MethodAverage = require('./averages/MethodAverage');

var _MethodAverage2 = _interopRequireDefault(_MethodAverage);

var _ModuleMethodReport = require('./ModuleMethodReport');

var _ModuleMethodReport2 = _interopRequireDefault(_ModuleMethodReport);

var _AnalyzeError = require('../../analyze/AnalyzeError');

var _AnalyzeError2 = _interopRequireDefault(_AnalyzeError);

var _MathUtil = require('../../utils/MathUtil');

var _MathUtil2 = _interopRequireDefault(_MathUtil);

var _ObjectUtil = require('../../utils/ObjectUtil');

var _ObjectUtil2 = _interopRequireDefault(_ObjectUtil);

var _ReportType = require('../../types/ReportType');

var _ReportType2 = _interopRequireDefault(_ReportType);

var _TransformFormat = require('../../transform/TransformFormat');

var _TransformFormat2 = _interopRequireDefault(_TransformFormat);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides the module report object which stores data pertaining to a single file / module being processed.
 *
 * All ES Module classes are stored in the `classes` member variable as ClassReports. Methods that are not part of a
 * class are stored as ModuleMethodReport instances in the `methods` member variable.
 *
 * Various helper methods found in ModuleReport and AbstractReport help increment associated data during collection.
 */
var ModuleReport = function (_AbstractReport) {
   _inherits(ModuleReport, _AbstractReport);

   _createClass(ModuleReport, [{
      key: 'type',

      /**
       * Returns the enum for the report type.
       * @returns {ReportType}
       */
      get: function get() {
         return _ReportType2.default.MODULE;
      }

      /**
       * Initializes the report.
       *
       * @param {number}   lineStart - Start line of file / module.
       *
       * @param {number}   lineEnd - End line of file / module.
       *
       * @param {object}   settings - An object hash of the settings used in generating this report via ESComplexModule.
       */

   }]);

   function ModuleReport() {
      var lineStart = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
      var lineEnd = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
      var settings = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      _classCallCheck(this, ModuleReport);

      /**
       * Stores the settings used to generate the module report.
       * @type {object}
       */
      var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ModuleReport).call(this, new _AggregateMethodReport2.default(lineStart, lineEnd)));

      _this.settings = (typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object' ? settings : {};

      /**
       * Stores all ClassReport data for the module.
       * @type {Array<ClassReport>}
       */
      _this.classes = [];

      /**
       * Stores all parsed dependencies.
       * @type {Array}
       */
      _this.dependencies = [];

      /**
       * Stores any analysis errors.
       * @type {Array}
       */
      _this.errors = [];

      /**
       * Stores the file path of the module / file. The file path is only defined as supplied when processing projects.
       * @type {string}
       */
      _this.filePath = void 0;

      /**
       * Stores the end line for the module / file.
       * @type {number}
       */
      _this.lineEnd = lineEnd;

      /**
       * Stores the start line for the module / file.
       * @type {number}
       */
      _this.lineStart = lineStart;

      /**
       * Measures the average method maintainability index for the module / file.
       * @type {number}
       */
      _this.maintainability = 0;

      /**
       * Stores all module ModuleMethodReport data found outside of any ES6 classes.
       * @type {Array<ModuleMethodReport>}
       */
      _this.methods = [];

      /**
       * Stores the average method metric data.
       * @type {MethodAverage}
       */
      _this.methodAverage = new _MethodAverage2.default();

      /**
       * Stores the current class report scope stack which is lazily created in `createScope`.
       * @type {Array<ClassReport>}
       */
      _this._scopeStackClass = void 0;

      /**
       * Stores the current method report scope stack which is lazily created in `createScope`.
       * @type {Array<ClassMethodReport|ModuleMethodReport>}
       */
      _this._scopeStackMethod = void 0;

      /**
       * Stores the active source path of the module / file. This path is respective of how the file is referenced in
       * the source code itself. `srcPath` is only defined as supplied when processing projects.
       * @type {string}
       */
      _this.srcPath = void 0;

      /**
       * Stores the active source path alias of the module / file. This path is respective of how the file is
       * referenced in the source code itself when aliased including NPM and JSPM modules which provide a `main` entry.
       * `srcPathAlias` is only defined as supplied when processing projects.
       * @type {string}
       */
      _this.srcPathAlias = void 0;
      return _this;
   }

   /**
    * Potentially adds given dependencies for tracking.
    *
    * @param {object|Array}   dependencies - Dependencies to add.
    */


   _createClass(ModuleReport, [{
      key: 'addDependencies',
      value: function addDependencies(dependencies) {
         if ((typeof dependencies === 'undefined' ? 'undefined' : _typeof(dependencies)) === 'object' || Array.isArray(dependencies)) {
            this.dependencies = this.dependencies.concat(dependencies);
         }
      }

      /**
       * Clears all errors stored in the module report and by default any class reports and module methods.
       *
       * @param {boolean}  clearChildren - (Optional) If false then class and module method errors are not cleared;
       *                                   default (true).
       */

   }, {
      key: 'clearErrors',
      value: function clearErrors() {
         var clearChildren = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

         this.errors = [];

         if (clearChildren) {
            this.classes.forEach(function (report) {
               report.clearErrors();
            });
            this.methods.forEach(function (report) {
               report.clearErrors();
            });
         }
      }

      /**
       * Creates a report scope when a class or method is entered.
       *
       * @param {string}   type - Type of report to create.
       * @param {string}   name - Name of the class or method.
       * @param {number}   lineStart - Start line of method.
       * @param {number}   lineEnd - End line of method.
       * @param {number}   params - Number of parameters for method.
       *
       * @return {object}
       */

   }, {
      key: 'createScope',
      value: function createScope(type) {
         var name = arguments.length <= 1 || arguments[1] === undefined ? '' : arguments[1];
         var lineStart = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
         var lineEnd = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
         var params = arguments.length <= 4 || arguments[4] === undefined ? 0 : arguments[4];

         var report = void 0;

         switch (type) {
            case 'class':
               report = new _ClassReport2.default(name, lineStart, lineEnd);
               this.classes.push(report);

               // Lazily create class scope stack if not currently initialized.
               if (!Array.isArray(this._scopeStackClass)) {
                  this._scopeStackClass = [];
               }

               this._scopeStackClass.push(report);

               break;

            case 'method':
               {
                  // Increment aggregate method report params.
                  this.incrementParams(params);

                  // If an existing class report / scope exists also push the method to the class report.
                  var classReport = this.getCurrentClassReport();

                  if (classReport) {
                     report = new _ClassMethodReport2.default(name, lineStart, lineEnd, params);

                     classReport.incrementParams(params);
                     classReport.methods.push(report);
                  } else {
                     report = new _ModuleMethodReport2.default(name, lineStart, lineEnd, params);

                     // Add this report to the module methods as there is no current class report.
                     this.methods.push(report);
                  }

                  // Lazily create method scope stack if not currently initialized.
                  if (!Array.isArray(this._scopeStackMethod)) {
                     this._scopeStackMethod = [];
                  }

                  this._scopeStackMethod.push(report);

                  break;
               }

            default:
               throw new Error('createScope error: Unknown scope type (' + type + ').');
         }

         return report;
      }

      /**
       * Cleans up any house keeping member variables.
       *
       * @returns {ModuleReport}
       */

   }, {
      key: 'finalize',
      value: function finalize() {
         delete this._scopeStackClass;
         delete this._scopeStackMethod;

         return _MathUtil2.default.toFixedTraverse(this);
      }

      /**
       * Returns the current class report.
       *
       * @returns {ClassReport}
       */

   }, {
      key: 'getCurrentClassReport',
      value: function getCurrentClassReport() {
         if (!Array.isArray(this._scopeStackClass)) {
            return void 0;
         }
         return this._scopeStackClass.length > 0 ? this._scopeStackClass[this._scopeStackClass.length - 1] : void 0;
      }

      /**
       * Returns the current method report.
       *
       * @returns {ClassMethodReport|ModuleMethodReport}
       */

   }, {
      key: 'getCurrentMethodReport',
      value: function getCurrentMethodReport() {
         if (!Array.isArray(this._scopeStackMethod)) {
            return void 0;
         }
         return this._scopeStackMethod.length > 0 ? this._scopeStackMethod[this._scopeStackMethod.length - 1] : void 0;
      }

      /**
       * Gets all errors stored in the module report and by default any module methods and class reports.
       *
       * @param {object}   options - Optional parameters.
       * @property {boolean}  includeChildren - If false then module errors are not included; default (true).
       * @property {boolean}  includeReports - If true then results will be an array of object hashes containing `source`
       *                                      (the source report object of the error) and `error`
       *                                      (an AnalyzeError instance) keys; default (false).
       *
       * @returns {Array<AnalyzeError|{error: AnalyzeError, source: *}>}
       */

   }, {
      key: 'getErrors',
      value: function getErrors() {
         var _this2 = this,
             _ref;

         var options = arguments.length <= 0 || arguments[0] === undefined ? { includeChildren: true, includeReports: false } : arguments[0];

         /* istanbul ignore if */
         if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
            throw new TypeError('getErrors error: \'options\' is not an \'object\'.');
         }

         // By default set includeChildren to true.
         /* istanbul ignore if */
         if (typeof options.includeChildren !== 'boolean') {
            options.includeChildren = true;
         }

         // If `includeReports` is true then return an object hash with the source and error otherwise return the error.
         var errors = options.includeReports ? this.errors.map(function (entry) {
            return { error: entry, source: _this2 };
         }) : (_ref = []).concat.apply(_ref, _toConsumableArray(this.errors));

         // If `includeChildren` is true then traverse all children reports for errors.
         if (options.includeChildren) {
            // Add module to all children errors.
            if (options.includeReports) {
               (function () {
                  var _errors;

                  var childErrors = [];

                  _this2.methods.forEach(function (report) {
                     childErrors.push.apply(childErrors, _toConsumableArray(report.getErrors(options)));
                  });
                  _this2.classes.forEach(function (report) {
                     childErrors.push.apply(childErrors, _toConsumableArray(report.getErrors(options)));
                  });

                  // Add module to object hash.
                  childErrors.forEach(function (error) {
                     error.module = _this2;
                  });

                  // Push to all module errors.
                  (_errors = errors).push.apply(_errors, childErrors);
               })();
            } else {
               this.methods.forEach(function (report) {
                  var _errors2;

                  (_errors2 = errors).push.apply(_errors2, _toConsumableArray(report.getErrors(options)));
               });
               this.classes.forEach(function (report) {
                  var _errors3;

                  (_errors3 = errors).push.apply(_errors3, _toConsumableArray(report.getErrors(options)));
               });
            }
         }

         // If `options.query` is defined then filter errors against the query object.
         if (_typeof(options.query) === 'object') {
            errors = errors.filter(function (error) {
               return _ObjectUtil2.default.safeEqual(options.query, error);
            });
         }

         return errors;
      }

      /**
       * Returns the supported transform formats.
       *
       * @returns {Object[]}
       */

   }, {
      key: 'getName',


      /**
       * Returns the name / id associated with this report.
       * @returns {string}
       */
      value: function getName() {
         return typeof this.srcPath === 'string' ? this.srcPath : '';
      }

      /**
       * Returns the setting indexed by the given key.
       *
       * @param {string}   key - A key used to store the setting parameter.
       * @param {*}        defaultValue - A default value to return if no setting for the given key is currently stored.
       *
       * @returns {*}
       */

   }, {
      key: 'getSetting',
      value: function getSetting(key) {
         var defaultValue = arguments.length <= 1 || arguments[1] === undefined ? undefined : arguments[1];

         /* istanbul ignore if */
         if (typeof key !== 'string' || key === '') {
            throw new TypeError('getSetting error: \'key\' is not a \'string\' or is empty.');
         }

         return _typeof(this.settings) === 'object' && typeof this.settings[key] !== 'undefined' ? this.settings[key] : defaultValue;
      }

      /**
       * Increments the Halstead `metric` for the given `identifier` for the ModuleReport and any current class or method
       * report being tracked.
       *
       * @param {string}   metric - A Halstead metric name.
       * @param {string}   identifier - A Halstead identifier name.
       */

   }, {
      key: 'halsteadItemEncountered',
      value: function halsteadItemEncountered(metric, identifier) {
         var currentClassReport = this.getCurrentClassReport();
         var currentMethodReport = this.getCurrentMethodReport();

         this.incrementHalsteadItems(metric, identifier);

         if (currentClassReport) {
            currentClassReport.incrementHalsteadItems(metric, identifier);
         }

         if (currentMethodReport) {
            currentMethodReport.incrementHalsteadItems(metric, identifier);
         }
      }

      /**
       * Increments the cyclomatic metric for the ModuleReport and any current class or method report being tracked.
       *
       * @param {number}   amount - Amount to increment.
       */

   }, {
      key: 'incrementCyclomatic',
      value: function incrementCyclomatic(amount) {
         var currentClassReport = this.getCurrentClassReport();
         var currentMethodReport = this.getCurrentMethodReport();

         this.methodAggregate.cyclomatic += amount;

         if (currentClassReport) {
            currentClassReport.methodAggregate.cyclomatic += amount;
         }
         if (currentMethodReport) {
            currentMethodReport.cyclomatic += amount;
         }
      }

      /**
       * Increments the logical SLOC (source lines of code) metric for the ModuleReport and any current class or method
       * report being tracked.
       *
       * @param {number}   amount - Amount to increment.
       */

   }, {
      key: 'incrementLogicalSloc',
      value: function incrementLogicalSloc(amount) {
         var currentClassReport = this.getCurrentClassReport();
         var currentMethodReport = this.getCurrentMethodReport();

         this.methodAggregate.sloc.logical += amount;

         if (currentClassReport) {
            currentClassReport.methodAggregate.sloc.logical += amount;
         }
         if (currentMethodReport) {
            currentMethodReport.sloc.logical += amount;
         }
      }

      /**
       * Deserializes a JSON object representing a ModuleReport.
       *
       * @param {object}   object - A JSON object of a ModuleReport that was previously serialized.
       *
       * @returns {ModuleReport}
       */

   }, {
      key: 'popScope',


      /**
       * Pops a report scope.
       *
       * @param {string} type - The report scope `class` or `method` to pop off the given stack.
       * @returns {*}
       */
      value: function popScope(type) {
         switch (type) {
            case 'class':
               if (Array.isArray(this._scopeStackClass)) {
                  this._scopeStackClass.pop();
               }
               return this.getCurrentClassReport();

            case 'method':
               if (Array.isArray(this._scopeStackMethod)) {
                  this._scopeStackMethod.pop();
               }
               return this.getCurrentMethodReport();

            default:
               throw new Error('popScope error: Unknown scope type (' + type + ').');
         }
      }

      /**
       * Processes all TraitHalstead identifier data.
       *
       * @param {string}         metric - The Halstead metric being processed.
       * @param {Array<string>}  identifiers - An array of Halstead identifiers.
       */

   }, {
      key: 'processHalsteadItems',
      value: function processHalsteadItems(metric, identifiers) {
         var _this3 = this;

         identifiers.forEach(function (identifier) {
            _this3.halsteadItemEncountered(metric, identifier);
         });
      }

      /**
       * Sets the setting indexed by the given key and returns true if successful.
       *
       * @param {string}   key - A key used to store the setting parameter.
       * @param {*}        value - A value to set to `this.settings[key]`.
       *
       * @returns {boolean}
       */

   }, {
      key: 'setSetting',
      value: function setSetting(key, value) {
         /* istanbul ignore if */
         if (typeof key !== 'string' || key === '') {
            throw new TypeError('setSetting error: \'key\' is not a \'string\' or is empty.');
         }

         if (this.settings === 'object') {
            this.settings[key] = value;
            return true;
         }

         return false;
      }
   }], [{
      key: 'getFormats',
      value: function getFormats() {
         return _TransformFormat2.default.getFormats(_ReportType2.default.MODULE);
      }
   }, {
      key: 'parse',
      value: function parse(object) {
         /* istanbul ignore if */
         if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {
            throw new TypeError('parse error: \'object\' is not an \'object\'.');
         }

         var report = Object.assign(new ModuleReport(), object);

         if (report.classes.length > 0) {
            report.classes = report.classes.map(function (classReport) {
               return _ClassReport2.default.parse(classReport);
            });
         }

         if (report.errors.length > 0) {
            report.errors = report.errors.map(function (error) {
               return _AnalyzeError2.default.parse(error);
            });
         }

         if (report.methods.length > 0) {
            report.methods = report.methods.map(function (methodReport) {
               return _ModuleMethodReport2.default.parse(methodReport);
            });
         }

         return report;
      }
   }]);

   return ModuleReport;
}(_AbstractReport3.default);

exports.default = ModuleReport;
module.exports = exports['default'];