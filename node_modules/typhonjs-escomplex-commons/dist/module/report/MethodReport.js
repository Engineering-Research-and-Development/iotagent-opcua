'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AggregateMethodReport = require('./AggregateMethodReport');

var _AggregateMethodReport2 = _interopRequireDefault(_AggregateMethodReport);

var _AnalyzeError = require('../../analyze/AnalyzeError');

var _AnalyzeError2 = _interopRequireDefault(_AnalyzeError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides the method report object which stores data pertaining to a single method / function.
 */
var MethodReport = function (_AggregateMethodRepor) {
  _inherits(MethodReport, _AggregateMethodRepor);

  /**
   * Initializes method report.
   *
   * @param {string}   name - Name of the method.
   * @param {number}   lineStart - Start line of method.
   * @param {number}   lineEnd - End line of method.
   * @param {number}   params - Number of parameters for method.
   */
  function MethodReport() {
    var name = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
    var lineStart = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
    var lineEnd = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
    var params = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];

    _classCallCheck(this, MethodReport);

    /**
     * Stores any analysis errors.
     * @type {Array}
     */
    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(MethodReport).call(this, lineStart, lineEnd));

    _this.errors = [];

    /**
     * Stores the end line for the method.
     * @type {number}
     */
    _this.lineEnd = lineEnd;

    /**
     * Stores the start line for the method.
     * @type {number}
     */
    _this.lineStart = lineStart;

    /**
     * The name of the method.
     * @type {string}
     */
    _this.name = name;

    /**
     * The number of parameters for the method or report.
     * @type {number}
     */
    _this.params = params;
    return _this;
  }

  /**
   * Clears all errors stored in the method report.
   */


  _createClass(MethodReport, [{
    key: 'clearErrors',
    value: function clearErrors() {
      this.errors = [];
    }

    /**
     * Gets all errors stored in the method report.
     *
     * @param {object}   options - Optional parameters.
     * @property {boolean}  includeChildren - If false then module errors are not included; default (true).
     * @property {boolean}  includeReports - If true then results will be an array of object hashes containing `source`
     *                                      (the source report object of the error) and `error`
     *                                      (an AnalyzeError instance) keys; default (false).
     *
     * @returns {Array<AnalyzeError|{error: AnalyzeError, source: *}>}
     */

  }, {
    key: 'getErrors',
    value: function getErrors() {
      var _this2 = this,
          _ref;

      var options = arguments.length <= 0 || arguments[0] === undefined ? { includeChildren: true, includeReports: false } : arguments[0];

      /* istanbul ignore if */
      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
        throw new TypeError('getErrors error: \'options\' is not an \'object\'.');
      }

      // By default set includeChildren to true.
      /* istanbul ignore if */
      if (typeof options.includeChildren !== 'boolean') {
        options.includeChildren = true;
      }

      // If `includeReports` is true then return an object hash with the source and error otherwise return the error.
      return options.includeReports ? this.errors.map(function (entry) {
        return { error: entry, source: _this2 };
      }) : (_ref = []).concat.apply(_ref, _toConsumableArray(this.errors));
    }

    /**
     * Returns the name / id associated with this report.
     * @returns {string}
     */

  }, {
    key: 'getName',
    value: function getName() {
      return this.name;
    }

    /**
     * Deserializes a JSON object representing a ClassMethodReport.
     *
     * @param {ClassMethodReport|ModuleMethodReport}   targetObject - A target object to hydrate.
     *
     * @param {object}   jsonObject - A JSON object of a class or module method report that was previously serialized.
     *
     * @returns {ClassMethodReport|ModuleMethodReport}
     * @protected
     */

  }], [{
    key: '_parse',
    value: function _parse(targetObject, jsonObject) {
      /* istanbul ignore if */
      if ((typeof jsonObject === 'undefined' ? 'undefined' : _typeof(jsonObject)) !== 'object') {
        throw new TypeError('parse error: \'jsonObject\' is not an \'object\'.');
      }

      var methodReport = Object.assign(targetObject, jsonObject);

      if (methodReport.errors.length > 0) {
        methodReport.errors = methodReport.errors.map(function (error) {
          return _AnalyzeError2.default.parse(error);
        });
      }

      return methodReport;
    }
  }]);

  return MethodReport;
}(_AggregateMethodReport2.default);

exports.default = MethodReport;
module.exports = exports['default'];