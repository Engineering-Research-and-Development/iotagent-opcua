'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _AbstractReport2 = require('./AbstractReport');

var _AbstractReport3 = _interopRequireDefault(_AbstractReport2);

var _AggregateMethodReport = require('./AggregateMethodReport');

var _AggregateMethodReport2 = _interopRequireDefault(_AggregateMethodReport);

var _ClassMethodReport = require('./ClassMethodReport');

var _ClassMethodReport2 = _interopRequireDefault(_ClassMethodReport);

var _MethodAverage = require('./averages/MethodAverage');

var _MethodAverage2 = _interopRequireDefault(_MethodAverage);

var _AnalyzeError = require('../../analyze/AnalyzeError');

var _AnalyzeError2 = _interopRequireDefault(_AnalyzeError);

var _ReportType = require('../../types/ReportType');

var _ReportType2 = _interopRequireDefault(_ReportType);

var _ObjectUtil = require('../../utils/ObjectUtil');

var _ObjectUtil2 = _interopRequireDefault(_ObjectUtil);

var _TransformFormat = require('../../transform/TransformFormat');

var _TransformFormat2 = _interopRequireDefault(_TransformFormat);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Provides the class report object which stores data pertaining to a single ES6 class.
 *
 * Methods that are stored as ClassMethodReport instances in the `methods` member variable.
 */
var ClassReport = function (_AbstractReport) {
  _inherits(ClassReport, _AbstractReport);

  _createClass(ClassReport, [{
    key: 'type',

    /**
     * Returns the enum for the report type.
     * @returns {ReportType}
     */
    get: function get() {
      return _ReportType2.default.CLASS;
    }

    /**
     * Initializes class report.
     *
     * @param {string}   name - Name of the class.
     * @param {number}   lineStart - Start line of class.
     * @param {number}   lineEnd - End line of class.
     */

  }]);

  function ClassReport() {
    var name = arguments.length <= 0 || arguments[0] === undefined ? '' : arguments[0];
    var lineStart = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
    var lineEnd = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];

    _classCallCheck(this, ClassReport);

    /**
     * Stores any analysis errors.
     * @type {Array}
     */
    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(ClassReport).call(this, new _AggregateMethodReport2.default(lineStart, lineEnd)));

    _this.errors = [];

    /**
     * Stores the end line for the class.
     * @type {number}
     */
    _this.lineEnd = lineEnd;

    /**
     * Stores the start line for the class.
     * @type {number}
     */
    _this.lineStart = lineStart;

    /**
     * Stores all method data.
     * @type {Array<ClassMethodReport>}
     */
    _this.methods = [];

    /**
     * Stores the average method metric data.
     * @type {HalsteadAverage}
     */
    _this.methodAverage = new _MethodAverage2.default();

    /**
     * The name of the class.
     * @type {string}
     */
    _this.name = name;
    return _this;
  }

  /**
   * Clears all errors stored in the class report and by default any class methods.
   *
   * @param {boolean}  clearChildren - (Optional) If false then class method errors are not cleared; default (true).
   */


  _createClass(ClassReport, [{
    key: 'clearErrors',
    value: function clearErrors() {
      var clearChildren = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

      this.errors = [];

      if (clearChildren) {
        this.methods.forEach(function (report) {
          report.clearErrors();
        });
      }
    }

    /**
     * Gets all errors stored in the class report and by default any class methods.
     *
     * @param {object}   options - Optional parameters.
     * @property {boolean}  includeChildren - If false then module errors are not included; default (true).
     * @property {boolean}  includeReports - If true then results will be an array of object hashes containing `source`
     *                                      (the source report object of the error) and `error`
     *                                      (an AnalyzeError instance) keys; default (false).
     *
     * @returns {Array<AnalyzeError|{error: AnalyzeError, source: *}>}
     */

  }, {
    key: 'getErrors',
    value: function getErrors() {
      var _this2 = this,
          _ref;

      var options = arguments.length <= 0 || arguments[0] === undefined ? { includeChildren: true, includeReports: false } : arguments[0];

      /* istanbul ignore if */
      if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
        throw new TypeError('getErrors error: \'options\' is not an \'object\'.');
      }

      // By default set includeChildren to true.
      /* istanbul ignore if */
      if (typeof options.includeChildren !== 'boolean') {
        options.includeChildren = true;
      }

      // If `includeReports` is true then return an object hash with the source and error otherwise return the error.
      var errors = options.includeReports ? this.errors.map(function (entry) {
        return { error: entry, source: _this2 };
      }) : (_ref = []).concat.apply(_ref, _toConsumableArray(this.errors));

      // If `includeChildren` is true then traverse all children reports for errors.
      if (options.includeChildren) {
        // Add class to all children errors.
        if (options.includeReports) {
          (function () {
            var _errors;

            var childErrors = [];

            _this2.methods.forEach(function (report) {
              childErrors.push.apply(childErrors, _toConsumableArray(report.getErrors(options)));
            });

            // Add module to object hash.
            childErrors.forEach(function (error) {
              error.class = _this2;
            });

            // Push to all module errors.
            (_errors = errors).push.apply(_errors, childErrors);
          })();
        } else {
          this.methods.forEach(function (report) {
            var _errors2;

            (_errors2 = errors).push.apply(_errors2, _toConsumableArray(report.getErrors(options)));
          });
        }
      }

      // If `options.query` is defined then filter errors against the query object.
      if (_typeof(options.query) === 'object') {
        errors = errors.filter(function (error) {
          return _ObjectUtil2.default.safeEqual(options.query, error);
        });
      }

      return errors;
    }

    /**
     * Returns the supported transform formats.
     *
     * @returns {Object[]}
     */

  }, {
    key: 'getName',


    /**
     * Returns the name / id associated with this report.
     * @returns {string}
     */
    value: function getName() {
      return this.name;
    }

    /**
     * Deserializes a JSON object representing a ClassReport.
     *
     * @param {object}   object - A JSON object of a ClassReport that was previously serialized.
     *
     * @returns {ClassReport}
     */

  }], [{
    key: 'getFormats',
    value: function getFormats() {
      return _TransformFormat2.default.getFormats(_ReportType2.default.CLASS);
    }
  }, {
    key: 'parse',
    value: function parse(object) {
      /* istanbul ignore if */
      if ((typeof object === 'undefined' ? 'undefined' : _typeof(object)) !== 'object') {
        throw new TypeError('parse error: \'object\' is not an \'object\'.');
      }

      var classReport = Object.assign(new ClassReport(), object);

      if (classReport.errors.length > 0) {
        classReport.errors = classReport.errors.map(function (error) {
          return _AnalyzeError2.default.parse(error);
        });
      }

      if (classReport.methods.length > 0) {
        classReport.methods = classReport.methods.map(function (methodReport) {
          return _ClassMethodReport2.default.parse(methodReport);
        });
      }

      return classReport;
    }
  }]);

  return ClassReport;
}(_AbstractReport3.default);

exports.default = ClassReport;
module.exports = exports['default'];